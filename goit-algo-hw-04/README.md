# Порівняння алгоритмів сортування в Python

У даній роботі виконано порівняльний аналіз трьох алгоритмів сортування:
- сортування вставками (Insertion sort)
- сортування злиттям (Merge sort)
- вбудований алгоритм Python — Timsort (`sorted`)

Метою роботи є емпірично перевірити швидкодію алгоритмів на різних наборах даних
та показати, чому в Python зазвичай використовують вбудовані алгоритми сортування.

---

## Опис алгоритмів

**Сортування вставками** — простий алгоритм, який добре працює на вже відсортованих
або майже відсортованих масивах, але має квадратичну складність O(n²) у гіршому випадку.

**Сортування злиттям** — алгоритм із теоретичною складністю O(n log n), який стабільно
працює незалежно від структури вхідних даних, але не є адаптивним.

**Timsort** — гібридний алгоритм, який поєднує сортування вставками та сортування злиттям.
Він здатний ефективно використовувати частково або повністю відсортовані дані.

---

## Методика тестування

Для вимірювання часу виконання алгоритмів використовувався модуль `timeit`.
Кожен алгоритм тестувався на копії одного й того ж набору даних, щоб забезпечити
коректне порівняння результатів.

Було використано три набори даних:
- не відсортований список
- список, відсортований у зворотному порядку
- вже відсортований список

Час виконання визначався як мінімальне значення з кількох повторів.

---

## Результати

### DATASET: random
- Insertion sort: 0.1777 s  
- Merge sort: 0.0079 s  
- Timsort: 0.00017 s  

### DATASET: reversed
- Insertion sort: 0.4647 s  
- Merge sort: 0.0073 s  
- Timsort: 0.00007 s  

### DATASET: sorted
- Insertion sort: 0.00039 s  
- Merge sort: 0.0072 s  
- Timsort: 0.00007 s  

---

## Висновки

Експериментальні результати показали, що сортування вставками є дуже повільним
на масивах, відсортованих у зворотному порядку, що підтверджує його квадратичну
складність O(n²). Водночас на вже відсортованих даних цей алгоритм працює значно швидше.

Сортування злиттям демонструє стабільний час виконання незалежно від структури
вхідних даних, що відповідає теоретичній складності O(n log n), однак воно не
адаптується до частково відсортованих масивів.

Вбудований алгоритм Python (Timsort) показав найкращі результати у всіх тестах.
Це пояснюється тим, що він поєднує переваги сортування вставками та сортування злиттям
і ефективно працює з реальними даними.

Отримані результати підтверджують, що використання вбудованих алгоритмів сортування
Python є значно ефективнішим, ніж реалізація власних алгоритмів у більшості
практичних випадків.
