# Порівняння ефективності жадібного алгоритму та динамічного програмування

## 1. Жадібний алгоритм (find_coins_greedy)

* **Час виконання:** Миттєвий. Складність алгоритму O(N), де N — кількість номіналів монет. Час майже не залежить від
  величини суми, оскільки алгоритм проходить по списку монет лише один раз.
* **Ефективність:** Дуже висока для стандартних монетних систем.
* **Недоліки:** Може не видати оптимальне (мінімальне) рішення для нестандартних наборів монет, хоча для нашого
  набору [50, 25, 10, 5, 2, 1] працює коректно.

## 2. Алгоритм динамічного програмування (find_coins_dynamic)

* **Час виконання:** Значно повільніший. Складність залежить від суми видачі: O(Amount * N). При збільшенні суми (
  наприклад, до 5000 і більше) час виконання суттєво зростає, оскільки алгоритму потрібно обчислити оптимальний шлях для
  кожного числа від 0 до заданої суми.
* **Ефективність:** Гарантує знаходження мінімальної кількості монет для будь-якого набору номіналів.
* **Недоліки:** Використовує більше пам'яті для збереження таблиці результатів та потребує більше обчислювальних
  ресурсів.

## Висновок

На основі проведених замірів часу можна стверджувати, що для великих сум **жадібний алгоритм є набагато ефективнішим**,
оскільки він працює на порядки швидше і не навантажує пам'ять.

Метод динамічного програмування доцільно використовувати лише у випадках, коли набір монет є специфічним і жадібний
підхід не гарантує правильного результату, або ж для невеликих сум решти.